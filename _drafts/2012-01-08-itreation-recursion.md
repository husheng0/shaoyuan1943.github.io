什么是迭代，什么是递归？在看 SICP 这本书以前，我对递归的认识就是，只要一个函数调用了它自己，那么这就是一个递归。其他的，则都是迭代。 这样子理解其实没错，但还没有触及到递归的本质。下面就说说什么是真正的递归。 举个例子来说吧，比如我们写一个求阶乘的函数，如果用迭代的方法来写，就像这样： <pre>int fact(int n) { int result = 1; for (int i = 1; i &lt;= n; i++) { result *= i; } return result; }</pre> 用递归来写，就像这样： <pre>int fact(int n) { if (n == 1) { return 1; } else { return n * fact(n - 1); } }</pre> 上面两个函数是比较普通的写法，没有什么特别之处。下面就介绍第3种写法： <pre>int fact_helper(int n, int count, int result) { if (count &gt; n) { return result; } else { fact_helper(n, count + 1, result * count); } } int fact(int n) { fact_helper(n, 1, 1); }</pre> 若是在以前，我一定会把 fact-helper 视为递归，因为它调用了自己。但看了 SICP 之后，我更愿意把它归为迭代函数。书里面的说法是，这是一个递归的方法，但是一个迭代的流程。什么意思呢？就是写法上这是一个递归，但是计算的流程上，它是一个迭代。 接下来我们就分析一下，这三个函数的计算流程。 函数一，调用 fact（5）： <pre>i n result 1 5 1 2 5 1 3 5 2 4 5 6 5 5 24 6 5 120</pre> 函数二： <pre>n result 5 5 * fact(4) 4 4 * fact(3) 3 3 * fact(2) 2 2 * fact(1) 1 1</pre> 函数三： <pre>count n result 1 5 1 2 5 2 3 5 6 4 5 24 5 5 120 6 5 120</pre> 从上面的流程来看，函数一与函数三的计算流程是十分相似的，都是迭代的过程。为什么递归的写法能产生迭代的流程呢？我们注意到，函数三每次在进行递归时，都把当前所有临时变量的状态传递给了下一次迭代，这样的话，每一次递归的结果都不依赖于下一次递归的结果。而函数二则是典型的递归函数，每一次递归的结果都依赖于下一次递归的结果，比如 fact(5) = 5 * fact(4)。 整体的思想，迭代是把事情分成很多小步，然后一步一步地做，直到问题解决。而递归则是，每次把大的问题变成更小一些的问题，直到问题变得足够简单。 所以，看一个函数在本质上是迭代还是递归，我们应该观察该函数处理问题的流程，而不是仅它的写法。
